# overtchat.mk - Makefile FULL-AUTO pour Service-Overtchat
SHELL := /bin/bash
.PHONY: all clone prepare encrypt patch pack release clean mrproper strip_sources

# --- CONFIG (modifiable si besoin) ---
GIT_REPO   := https://github.com/servus033-cloud/Overtchat.git
GIT_BRANCH := main

TMP_BUILD  := $(PWD)/overtchat-V2_build
OUT_DIR    := $(PWD)/Service-Overtchat-release
PKG_NAME   := Service-Overtchat
SHC        := shc
CC         := gcc

# Structure attendue DANS le repo cloné (exactement)
REPO_BASE     := Service-Overtchat
LIB_SUB       := $(REPO_BASE)/Lib
CONF_SUB      := $(REPO_BASE)/Conf
BUILD_UNIX_IR := $(REPO_BASE)/Build/Unix/IriX
SETUP_SRC     := $(LIB_SUB)/setup-overtchat.sh  # existe; ne sera pas appelé par d'autres scripts

# Emplacement des binaires dans le package (sous Service-Overtchat/bin/)
PKG_BIN := bin

# --- CIBLES par défaut ---
all: release

clean:
	@printf "%s\n" "Nettoyage temporaire"
	@rm -rf "$(TMP_BUILD)" "$(OUT_DIR)"
	@printf "%s\n" "Nettoyage effectué"

# 1) clone propre
clone: clean
	@echo "Clonage de $(GIT_REPO) dans $(TMP_BUILD)"
	@git clone -b $(GIT_BRANCH) $(GIT_REPO) "$(TMP_BUILD)" || (echo "Erreur: git clone a échoué" && exit 1)
	@printf "%s\n" "Dépôt cloné"

# 2) préparation : vérifs + création dossiers bin
prepare: clone
	@command -v $(SHC) >/dev/null 2>&1 || (echo "Erreur: '$(SHC)' introuvable. Installe shc (apt install shc)"; exit 1)
	@printf "%s\n" "Création des dossiers : en cours..."
	@mkdir -p "$(TMP_BUILD)/$(PKG_BIN)"
	@mkdir -p "$(TMP_BUILD)/$(PKG_BIN)/Lib"
	@mkdir -p "$(TMP_BUILD)/$(PKG_BIN)/Conf"
	@mkdir -p "$(TMP_BUILD)/$(PKG_BIN)/Eggdrop"
	@mkdir -p "$(TMP_BUILD)/$(PKG_BIN)/Logs"
	@mkdir -p "$(TMP_BUILD)/$(PKG_BIN)/Build/UniX/IriX"
	@mkdir -p "$(TMP_BUILD)/$(PKG_BIN)/Build/Windows"
	@printf "%s\n" "Création des dossiers : terminé"

# Helper : ajoute temporairement shebang si absent (usé avant shc)
define ensure_shebang_cmd
first=$$(head -n1 "$(1)" 2>/dev/null || echo ""); \
case "$$first" in \
  \#\!/*) : ;; \
  *) (printf '%s\n' "#!/usr/bin/env bash" "" > "$(1).tmp.$$"; cat "$(1)" >> "$(1).tmp.$$"; mv "$(1).tmp.$$" "$(1)";) ;; \
esac
endef

# 3) encrypt : shc pour Lib/*.sh
encrypt: prepare
	@printf "%s\n" "Démarrage chiffrement (shc)"
	# Lib/*.sh
	@if ls "$(TMP_BUILD)/$(LIB_SUB)"/*.sh >/dev/null 2>&1; then \
	  for f in "$(TMP_BUILD)/$(LIB_SUB)"/*.sh; do \
	    name=$$(basename $$f .sh); \
	    out="$(TMP_BUILD)/$(PKG_BIN)/Lib/$$name"; \
	    printf "%s\n" "[build] $$f -> $$out"; \
	    cp "$$f" "$$f.bak.$$"; \
	    $(call ensure_shebang_cmd,$$f); \
	    $(SHC) -f "$$f" -o "$$out" >/dev/null 2>&1 || { printf "%s\n" "shc failed for $$f"; mv "$$f.bak.$$" "$$f"; exit 1; }; \
	    chmod +x "$$out" || true; \
	    mv "$$f.bak.$$" "$$f" >/dev/null 2>&1 || true; \
	  done; \
	else \
	  printf "%s\n" "Alerte > Aucun .sh dans $(LIB_SUB)"; \
	fi

# 4) patch: remplace appels littéraux vers Service-Overtchat/... par bin/...
patch: encrypt
	@printf "%s\n" "Patch des chemins pour pointer vers $(PKG_BIN)/"
	@if [ -f "$(TMP_BUILD)/Install/bin/patch_overtchat.sh" ]; then \
	  bash "$(TMP_BUILD)/Install/bin/patch_overtchat.sh" "$(TMP_BUILD)" "$(PKG_BIN)"; \
	else \
	  printf "%s\n" "Install/bin/patch_overtchat.sh absent dans le repo cloné"; exit 1; \
	fi
	@printf "%s\n" "Patch terminé"

# Optional: remove source .sh from the package (uncomment use if desired)
strip_sources:
	@printf "%s\n" "Suppression des sources .sh du build (ne laisse que bin/...)"; \
	find "$(TMP_BUILD)/$(REPO_BASE)" -type f -name "*.sh" -not -path "$(TMP_BUILD)/$(PKG_BIN)/*" -print0 | xargs -0 -r rm -f || true; \
	printf "%s\n" "Sources supprimées"

# 5) Prépare l'arbo pour l'archive : copy Conf/ Unix/ bin/ VERSION etc.
pack: patch
	@printf "%s\n" "Préparation de l'arbo pour l'archive $(OUT_DIR)"
	@rm -rf "$(OUT_DIR)/$(PKG_NAME)" || true
	@mkdir -p "$(OUT_DIR)/$(PKG_NAME)"
	# copier Conf (fichiers .conf), Unix (sauf scripts binaires), Logs optionnel
	@cp -a "$(TMP_BUILD)/$(REPO_BASE)/Conf" "$(OUT_DIR)/$(PKG_NAME)/" 2>/dev/null || true
	@cp -a "$(TMP_BUILD)/$(REPO_BASE)/Build" "$(OUT_DIR)/$(PKG_NAME)/" 2>/dev/null || true
	@cp -a "$(TMP_BUILD)/$(REPO_BASE)/Logs" "$(OUT_DIR)/$(PKG_NAME)/" 2>/dev/null || true
	# bin
	@mkdir -p "$(OUT_DIR)/$(PKG_NAME)/bin"
	@cp -a "$(TMP_BUILD)/$(PKG_BIN)"/* "$(OUT_DIR)/$(PKG_NAME)/bin/" 2>/dev/null || true
	# VERSION
	@cd "$(TMP_BUILD)" && (git rev-parse --short HEAD > "$(OUT_DIR)/$(PKG_NAME)/VERSION" 2>/dev/null || echo "unknown" > "$(OUT_DIR)/$(PKG_NAME)/VERSION")
	@printf "%s\n" "Arbo valide créée dans $(OUT_DIR)/$(PKG_NAME)"

# 6) release : tar.gz final
release: pack
	@printf "%s\n" "Compression finale (tar.gz)"
	@mkdir -p "$(OUT_DIR)"
	@ver="$$(cat "$(OUT_DIR)/$(PKG_NAME)/VERSION" 2>/dev/null || echo unknown)"; \
	tgt="$(OUT_DIR)/$(PKG_NAME)-v$$ver.tar.gz"; \
	cd "$(OUT_DIR)" && tar -czf "$$tgt" "$(PKG_NAME)"; \
	printf "%s\n" "Archive créée: $$tgt"
	mv "$(OUT_DIR)/$(PKG_NAME)/VERSION" "$(OUT_DIR)/$(PKG_NAME)-VERSION.txt" 2>/dev/null || true
	@printf "%s\n" "Release terminée. Fichier disponible dans $(OUT_DIR)"
	mv "$(OUT_DIR)/$(PKG_NAME)-v$$ver.tar.gz" "$(PWD)/$(PKG_NAME).tar.gz"; \
	printf "%s\n" "Fichier déplacé dans le répertoire courant."
